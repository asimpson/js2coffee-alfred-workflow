(function() {
  var BANNER, SWITCHES, UnsupportedError, basename, batch, cmd, compileFromStdin, compilePath, compileScript, encoding, file, fs, hidden, js2coffee, options, optparse, parseOptions, path, sources, tty, usage, version, writeFile, _;

  js2coffee = require('./js2coffee');

  _ = require('underscore');

  fs = require('fs');

  path = require('path');

  tty = require('tty');

  file = require('file');

  optparse = require('./optparse');

  BANNER = "Usage: js2coffee [options] path/to/script.js\n\n  js2coffee file.js\n  js2coffee file.js > output.coffee\n  cat file.js | js2coffee";

  SWITCHES = [['-v', '--version', 'Show js2coffee version'], ['-V', '--verbose', 'Be verbose'], ['-X', '--no_comments', 'Do not translate comments'], ['-l', '--show_src_lineno', 'Show src lineno\'s as comments'], ['-h', '--help', 'If you need help']];

  options = {};

  sources = [];

  encoding = 'utf-8';

  UnsupportedError = js2coffee.UnsupportedError;

  basename = path.basename;

  cmd = basename(process.argv[1]);

  parseOptions = function() {
    var optionParser;
    optionParser = new optparse.OptionParser(SWITCHES, BANNER);
    options = optionParser.parse(process.argv.slice(2));
    return sources = options["arguments"];
  };

  writeFile = function(dir, currfile, coffee) {
    var e, newFile, newPath, outputdir;
    outputdir = options.output || '.';
    try {
      if ((outputdir.search('/')) === -1) {
        outputdir = outputdir.concat('/');
      }
      newPath = outputdir + dir + '/';
      try {
        fs.statSync(newPath).isDirectory();
      } catch (_error) {
        e = _error;
        file.mkdirsSync(newPath);
      }
      currfile = (currfile.split('.'))[0] + '.coffee';
      newFile = newPath + currfile;
      if (options.verbose) {
        console.warn("writing %s ", newFile);
      }
      return fs.writeFileSync(newFile, coffee, encoding);
    } catch (_error) {
      e = _error;
      return console.warn(e);
    }
  };

  batch = function() {
    var callback, e, i, list, v, _i, _j, _len, _len1, _ref, _results;
    callback = function(dirPath, dirs, files) {
      var contents, e, f, output, readf, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        f = files[_i];
        try {
          if ((f.split('.'))[1] === 'js') {
            readf = dirPath + '/' + f;
            if (options.verbose) {
              console.warn("read file %s", readf);
            }
            contents = fs.readFileSync(readf, encoding);
            output = js2coffee.build(contents, options);
            _results.push(writeFile(dirPath, f, output));
          } else {
            _results.push(void 0);
          }
        } catch (_error) {
          e = _error;
          _results.push(console.warn(e));
        }
      }
      return _results;
    };
    _results = [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      i = sources[_i];
      try {
        if (fs.statSync(i).isDirectory()) {
          if (options.recursive) {
            _results.push(file.walkSync(i, callback));
          } else {
            list = [];
            _ref = fs.readdirSync(i);
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              v = _ref[_j];
              if (fs.statSync(v).isFile()) {
                list.add(v);
              }
            }
            _results.push(callback(i, '', list));
          }
        } else {
          _results.push(void 0);
        }
      } catch (_error) {
        e = _error;
      }
    }
    return _results;
  };

  compilePath = function(source, topLevel, base) {
    return fs.stat(source, function(err, stats) {
      if (err && err.code !== 'ENOENT') {
        throw err;
      }
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        if (topLevel && source.slice(-3) !== '.js') {
          source = "" + source + ".coffee";
          return compilePath(source, topLevel, base);
        }
        if (topLevel) {
          console.error("File not found: " + source);
          process.exit(1);
        }
        return;
      }
      if (stats.isDirectory()) {
        return fs.readdir(source, function(err, files) {
          var _i, _len, _results;
          if (err && err.code !== 'ENOENT') {
            throw err;
          }
          if ((err != null ? err.code : void 0) === 'ENOENT') {
            return;
          }
          _results = [];
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            file = files[_i];
            if (!hidden(file)) {
              _results.push(compilePath(path.join(source, file), false, base));
            }
          }
          return _results;
        });
      } else if (topLevel || path.extname(source) === '.js') {
        return compileScript(source);
      }
    });
  };

  hidden = function(file) {
    return /^\.|~$/.test(file);
  };

  compileScript = function(fname) {
    var code, compiled_code, err;
    try {
      if (options.verbose) {
        console.log("#### ---- " + fname);
      }
      code = fs.readFileSync(fname);
      compiled_code = js2coffee.build(code.toString(), options);
      return console.log(compiled_code);
    } catch (_error) {
      err = _error;
      console.warn(err instanceof Error && err.stack || ("ERROR: " + err + " while compiling " + file));
      if (options.stop_on_error) {
        return exit(1);
      }
    }
  };

  compileFromStdin = function() {
    var contents, output;
    contents = fs.readFileSync("/dev/stdin", encoding);
    output = js2coffee.build(contents, options);
    return console.log(output);
  };

  usage = function() {
    console.warn((new optparse.OptionParser(SWITCHES, BANNER)).help());
    return process.exit(0);
  };

  version = function() {
    return "js2coffee version " + js2coffee.VERSION;
  };

  exports.run = function() {
    var s, _i, _len, _results;
    parseOptions();
    if (options.help) {
      return usage();
    }
    if (options.version) {
      return console.log(version());
    }
    if (options.verbose) {
      console.log("#### " + version());
    }
    if (sources.length > 0) {
      _results = [];
      for (_i = 0, _len = sources.length; _i < _len; _i++) {
        s = sources[_i];
        _results.push(compilePath(s));
      }
      return _results;
    } else {
      if (!tty.isatty(process.stdin)) {
        return compileFromStdin('/dev/stdin');
      }
      return usage();
    }
  };

}).call(this);
